#!/usr/bin/env bash


# Primary server to request pg_basebackup
primary_server=
primary_port=

# Synchronous standby servers
synchronous_standby_servers=()
synchronous_standby_ports=()

# Asynchronous standby servers
asynchronous_standby_servers=()
asynchronous_standby_ports=()

all_standby_servers=()
all_standby_ports=()

# Context when setup cluster
pg_setup_version=

# Default start port
pg_start_port=24312


declare -A replication_tree=()


OLDPWD="${OLDPWD:-"$PWD"}"


#: Common


#: load_cluster_setting
#:   Load cluster settings.
#:   After set-up cluster, this function must be called at first.
#:
load_cluster_setting() {
  log_trace "==> load cluster setting: $PGENV_CLUSTER_ROOT/$PGENV_CLUSTER_CONFIG"
  cd "$OLDPWD" && cd "$PGENV_CLUSTER_ROOT" \
    && source "$PGENV_CLUSTER_CONFIG" && cd "$OLDPWD"

  # Overwrite forcely
  all_standby_servers=( ${synchronous_standby_servers[@]:-} ${asynchronous_standby_servers[@]:-} )
  all_standby_ports=( ${synchronous_standby_ports[@]:-} ${asynchronous_standby_ports[@]:-} )
}


#: switch_context
#:   Switch to the specified version.
#:
#: ex:
#:   $(switch_context && <do command>)
#:
switch_context() {
  cd "$PGENV_ROOT" && {
    cd "$PGENV_VERSIONS_DIR"/"$pg_setup_version"
  }
}

#: check_pg_version <version>
#:   Check whether the specified version equals pg_setup_version.
#:
#: ex:
#:   $(check_pg_version 10) )) && echo "version is 10"
#:
check_pg_version() {
  local ver="$1"
  test "${pg_setup_version%%.*}" = "$ver"
}

#: version_later_than <version>
#:   Check whether the specified version is later than pg_setup_version.
#:
#: ex:
#:   $(version_later_than 10) )) && echo "version is later than 10"
#:
version_later_than() {
  local ver="$1"
  (( "${pg_setup_version%%.*}" <= "$ver" ))
}


#: get_port_from_pidfile <instance>
#:   Get port number from the pidfile of the instance.
#:
get_port_from_pidfile() {
  local instance="$1"
  (
    cd "$PGENV_CLUSTER_ROOT"
    if [ -f "$instance"/postmaster.pid ]; then
      if (( $(check_pg_version 10) )); then
        tail -n 5 "$instance"/postmaster.pid | head -1
      else
        tail -n 4 "$instance"/postmaster.pid | head -1
      fi
    else
      echo ""
    fi
  )
}


#: do_basebackup <instance> <fork_off>
#:   Do pg_basebackup.
#:
do_basebackup() {
  local instance_dir="$1"
  local fork_off="${2:-}"
  local port="$primary_port"

  if [ -n "$fork_off" ]; then
    port="$(get_instance_port "$fork_off")"
    if [ -z "$port" ]; then
      abort "error: instance looks like invalid: $fork_off"
    fi
  fi

  (
    cd "$PGENV_CLUSTER_ROOT"
    instance_dir="$(resolve_link "$instance_dir")"

    local pgver="$(echo "${pg_setup_version}" | tr a-zA-Z .)"
    # version 10
    if [ "${pgver%%.*}" -ge "10" ]; then
      log_trace "==> pg_basebackup (later than 10): connect to localhost:$port"
      eval "$(switch_context && pwd)/bin/pg_basebackup" -R -w \
           -D "$instance_dir" --wal-method=stream -P -v -p $port -h localhost \
           --dbname="application_name=$(basename -- "$instance_dir")"
    else
      log_trace "==> pg_basebackup (earlier than 10): connect to localhost:$port"
      eval "$(switch_context && pwd)/bin/pg_basebackup" -R -w \
           -D "$instance_dir" --xlog -P -v -p $port -h localhost \
           --dbname="application_name=$(basename -- "$instance_dir")"
    fi
  )
}


#: write_cluster_info
#:   Save cluster settings.
#:
write_cluster_info() {
  log_info "==> save cluster information"

  local cluster_config="$PGENV_CLUSTER_ROOT/$PGENV_CLUSTER_CONFIG"

  log_info "$cluster_config"

  cat <<EOF > "$cluster_config"
#!/usr/bin/env bash
#
# Generated by pgenv at $(date +'%Y-%m-%d %H:%M:%S')
#

# Cluster settings
export PGENV_CLUSTER_ROOT="$(resolve_link "$PGENV_CLUSTER_ROOT")"

# Primary server
primary_server="$primary_server"
primary_port="$primary_port"

# Synchronous standby servers
synchronous_standby_servers=(${synchronous_standby_servers[@]:-})
synchronous_standby_ports=(${synchronous_standby_ports[@]:-})

# Asynchronous standby servers
asynchronous_standby_servers=(${asynchronous_standby_servers[@]:-})
asynchronous_standby_ports=(${asynchronous_standby_ports[@]:-})

# Sync + Async standby servers
all_standby_servers=(${synchronous_standby_servers[@]:-} ${asynchronous_standby_servers[@]:-})
all_standby_ports=(${synchronous_standby_ports[@]:-} ${asynchronous_standby_ports[@]:-})

# Context when setup cluster
pg_setup_version="$pg_setup_version"

# Version of pgenv
pgenv_version="$(pgenv -s -v)"

# Other information
pg_start_port=$pg_start_port   # Starting port number used when port number was not passed.
working_directory="$OLDPWD"    # This is the directory where you were when creating a cluster.

# Replication graph
# This information is extracted from pg_stat_replication view.
# So to analyze current exact replication state, all instances need to be started.
EOF

  {
    inspect_replication_tree
  } >> "$cluster_config"
}

#: analyze_replication_tree
#:   Analyze and dump replication tree.
#:
#: ex: Only analyze
#:   analyze_replication_tree > /dev/null
#:
analyze_replication_tree() {
  # Clear info
  replication_tree=()
  walk_replication_tree "$primary_server"
}


#: inspect_replication_tree
#:   Read pg_stat_replication view of all active or inactive nodes
#:   and analyze current replication state in the cluster.
#:
inspect_replication_tree() {
  local children=()
  local port=
  local instance=
  local status=0

  # Clear info
  replication_tree=()

  cd "$PGENV_CLUSTER_ROOT" && {
    for instance in "$primary_server" ${all_standby_servers[@]:-}; do
      port="$(get_instance_port "$instance")"

      if [ -n "$port" ]; then
        children=($("$(switch_context && pwd)/bin/psql"  \
                      -A -t -d postgres \
                      -p $port \
                      -c "select application_name from pg_stat_replication" 2> /dev/null)) || status=$?

        echo "replication_tree[\"$instance\"]=\"${children[@]:-}\""

        replication_tree["$instance"]="${children[@]:-}"
      fi
    done
  }
  cd "$OLDPWD"
}


#: walk_replication_tree <root>
#:   Read pg_stat_replication view of current active nodes
#:   and analyze current replication state in the cluster.
#:
walk_replication_tree() {
  local parent="$1"
  local port=
  local children=()
  local status=0

  port="$(get_instance_port "$parent")"
  if [ -n "$port" ]; then
    children=($("$(switch_context && pwd)/bin/psql" \
                  -A -t -d postgres \
                  -p $port \
                  -c "select application_name from pg_stat_replication" 2> /dev/null)) || status=$?

    echo "replication_tree[\"$parent\"]=\"${children[@]:-""}\""

    replication_tree["$parent"]="${children[@]:-}"

    local application_name=
    for application_name in ${children[@]:-""}; do
      # Walk recursively
      walk_replication_tree "$application_name"
    done
  fi
}


#: show_replication_tree <root> <nest_level>
#:   Show replication tree.
#:
show_replication_tree() {
  local root_node="${1:-""}"
  local nest_level="${2:-0}"
  local node=

  if [ -n "$(hash_get "rep" "$root_node")" ]; then
    return 0
  fi

  if [ -z "$root_node" ] && [ $nest_level -eq 0 ]; then
    for node in ${!replication_tree[*]}; do
      show_replication_tree "$node" 0
    done
    return 0
  elif [ "$root_node" = "$primary_server" ]; then
    printf "%s" "$primary_server -> "
    root_node="$primary_server"
  elif [ $nest_level -eq 0 ]; then
    printf "%s" "$root_node -> "
  else
    printf "%${nest_level}s%s" " " "$root_node -> "
  fi

  hash_set "rep" "$root_node" 1

  if [ -n "${replication_tree["$root_node"]:-""}" ]; then
    for node in ${replication_tree["$root_node"]}; do
      printf "%s " "$node"
    done
    printf "\n"
    for node in ${replication_tree["$root_node"]}; do
      show_replication_tree "$node" $((nest_level + 2))
    done
  else
    println
  fi
}


#: get_standby_node_index <node>
#:   Return the index number of the node in standby server array.
#:
#: ex:
#:   get_standby_node_index s1 # => 0
#:
get_standby_node_index() {
  local node="$1"
  local i=-1
  for ((i=0; i < ${#all_standby_servers[@]}; i++)); do
    if [ "$node" = "${all_standby_servers[$i]}" ]; then
      echo "$i"
      return 0
    fi
  done

  echo "-1"
}


#: add_standby_server <sync|async> <instance> <port>
#:   Add a standby server to all_standby_servers array.
#:
#: ex:
#:   add_standby_server "async" "newstandby" 9999
#:
add_standby_server() {
  local sync_state="$1"
  local instance_name="$2"
  local instance_port="$3"

  if [ "$sync_state" = "sync" ]; then
    synchronous_standby_servers[${#synchronous_standby_servers[@]}]="$instance_name"
    synchronous_standby_ports[${#synchronous_standby_ports[@]}]="$instance_port"
  elif [ "$sync_state" = "async" ]; then
    asynchronous_standby_servers[${#asynchronous_standby_servers[@]}]="$instance_name"
    asynchronous_standby_ports[${#asynchronous_standby_ports[@]}]="$instance_port"
  else
    abort "error: $(self -vv): invalid sync_state: $sync_state"
  fi

  all_standby_servers=(${synchronous_standby_servers[@]:-} ${asynchronous_standby_servers[@]:-})
  all_standby_ports=(${synchronous_standby_ports[@]:-} ${asynchronous_standby_ports[@]:-})
}


#: get_sync_state <parent> <child>
#:   Get sync_state between parent and child from pg_stat_replication view.
#:
get_sync_state() {
  local parent_node="$1"
  local child_node="$2"
  local port=
  local status=

  if [ "$parent_node" = "$primary_server" ]; then
    port="$primary_port"
  else
    port=$(get_instance_port "$parent_node")
    if [ -z "$port" ]; then
      log_warn "standby may not exist: $parent_node"
      return 0
    fi

    "$(switch_context && pwd)/bin/psql" \
      -A -t -d postgres \
      -p $port \
      -c "select sync_state from pg_stat_replication where application_name = '$child_node'" \
      2> /dev/null || status=$?

    if [ $status -ne 0 ]; then
      log_warn "failed to select pg_stat_replication: port=$port"
    fi
  fi
}


#: get_instance <name>
#:   Check whether the specified instance exists.
#:   If instance is valid, returns the same name as the original one,
#:   otherwise empty string.
#:
get_instance() {
  local instance_name="$1"
  local idx=-1

  if [ "$instance_name" = "$primary_server" ]; then
    echo "$instance_name"
  else
    idx="$(get_standby_node_index "$instance_name")"
    if [ $idx -lt 0 ]; then
      echo ""
    else
      echo "${all_standby_servers[$idx]:-""}"
    fi
  fi
}


#: get_instance <name>
#:   Check whether the specified instance exists.
#:
get_instance_port() {
  local instance_name="$1"
  local idx=-1

  if [ "$instance_name" = "$primary_server" ]; then
    echo "$primary_port"
  else
    idx="$(get_standby_node_index "$instance_name")"
    if [ "$idx" -lt "0" ]; then
      echo ""
    else
      echo "${all_standby_ports[$idx]:-""}"
    fi
  fi
}


#: Instance operations


#: create_intancer <instance> <options>
#:   Create a instace.
#:
create_instance() {
  local instance_name="$1"
  shift
  local initdb_options="$@"

  (
    cd "$PGENV_CLUSTER_ROOT"
    # Create instance
    eval "$(switch_context && pwd)/bin/initdb" $initdb_options "$instance_name"
  )
}


#: start_instance <instance> <options>
#:
#:
start_instance() {
  local instance_name="$1"
  shift
  local start_options="$@"

  log_info "==> start instance: $instance_name"
  log_info "exec: pg_ctl -D $instance_name start $start_options"

  (
    cd "$PGENV_CLUSTER_ROOT"
    # Start instance.
    eval "$(switch_context && pwd)/bin/pg_ctl" -D "$instance_name" start $start_options
  )
}


#: start_instance_safely <instance> <options>
#:   Start all instances safely.
#:
start_instance_safely() {
  local instance_name="$1"
  local instance="$(get_instance "$instance_name")"
  shift
  local start_options="$@"

  if [ -z "$instance" ]; then
    log_warn "$(self -v): invalid instance: $instance_name"
    return 0
  fi

  local servers=(${replication_tree["$instance_name"]:-""})
  local i= node=
  for node in ${servers[@]:-}; do
    if [ -n "$node" ]; then
      log_info "==> start instance safely: $instance_name"
      log_info "exec: pg_ctl -D $instance_name start"
      (
        cd "$PGENV_CLUSTER_ROOT"
        eval "$(switch_context && pwd)/bin/pg_ctl" -D "$instance_name" start $start_options
      )
      start_instance_safely "$node" "$start_options"
    fi
  done
}


#: start_all_instances
#:   Start all instances.
#:
start_all_instances() {
  local status=
  cd "$PGENV_CLUSTER_ROOT" && {
    status=0
    log_info "==> start cluster: $PGENV_CLUSTER_ROOT"
    start_instance "$primary_server" || status=$?
    if [ $status -ne 0 ]; then
      log_warn "server may be already running: $primary_server"
    fi

    local instance=
    for instance in ${all_standby_servers[@]:-}; do
      status=0
      start_instance "$instance" || status=$?
      if [ $status -ne 0 ]; then
        log_warn "instance may be already running: $instance"
      fi
    done
  }
  cd "$OLDPWD"
}


#: start_instance <name> <options>
#:   Stop an instance.
#:
stop_instance() {
  local instance_name="$1"
  shift
  local stop_options="$@"

  log_info "==> stop instance: $instance_name"
  log_info "exec: pg_ctl -D $instance_name stop $stop_options"

  (
    cd "$PGENV_CLUSTER_ROOT"
    # Stop instance.
    eval "$(switch_context && pwd)/bin/pg_ctl" -D "$instance_name" stop $stop_options
  )
}


#: stop_instance_safely
#:   Stop all instances safely.
#:
stop_instance_safely() {
  local instance_name="$1"
  local instance="$(get_instance "$instance_name")"
  shift
  local stop_options="$@"

  if [ -z "$instance" ]; then
    log_warn "$(self -v): invalid instance: $instance_name"
    return 0
  fi

  local servers=(${replication_tree["$instance_name"]:-""})
  local i=
  for instance in $(array_reverse "${servers[@]:-}"); do
    if [ -n "$instance" ]; then
      stop_instance_safely "$instance" "$stop_options"
    fi
  done

  log_info "==> stop instance safely: $instance_name"
  log_info "exec: pg_ctl -D $instance_name stop $stop_options"

  (
    cd "$PGENV_CLUSTER_ROOT"
    # Stop instance.
    eval "$(switch_context && pwd)/bin/pg_ctl" -D "$instance_name" stop $stop_options
  )

}


#: stop_all_instances <options>
#:   Stop all instances.
#:
stop_all_instances() {
  local status=0
  local stop_options="$@"
  local instance=

  for instance in $(array_reverse "${all_standby_servers[@]:-}"); do
    status=0
    if [ -n "$instance" ]; then
      stop_instance "$instance" "$stop_options" || status=$?
      test $status -ne 0 && log_warn "failed to stop instance: $instance"
    fi
  done

  status=0
  stop_instance "$primary_server" || status=$?
  test $status -ne 0 && log_warn "failed to stop instance: $primary_server"
}


#: attach_node <fork_off> <node>
#:   Attach a node to <fork_off>.
#:
attach_node() {
  local fork_off="$1"
  local new_node="$2"
  local status=0

  (
    cd "$PGENV_CLUSTER_ROOT"
    if [ -d "$new_node" ]; then
      error "error: directory already exists: $new_node"
      abort "hint: set other instance name"
    fi

    status=0
    do_basebackup "$new_node" "$fork_off" || status=$?
    if [ $status -ne 0 ]; then
      log_error "failed to do pg_basebackup"
      (cd "$OLDPWD" && rm -rf "$new_node")
      exit 1
    fi
    replace_string_in_file "replace" "$new_node/recovery.conf" \
                           "passfile=''.*''" ""
    replace_string_in_file "replace" "$new_node/recovery.conf" \
                           "target_session_attrs=[^ ']*" ""

    local include_file="$(resolve_link ${new_node}.conf)"
    local port="$pg_start_port"
    # Create include file for standby
    log_info "create include file for standby: $include_file"

    cat <<EOF > "$include_file"
port = $port
wal_keep_segments = 16
hot_standby = on
logging_collector = on
log_filename = 'postgresql-%Y-%m-%d.log'
EOF
    # Set include file (to overwrite settings)
    replace_string_in_file "del" "$new_node/postgresql.conf" \
                           "include = " "include = '$include_file'"

    cat <<EOF >> "$new_node/recovery.conf"
recovery_target_timeline = 'latest'
#restore_command = 'cp "$(resolve_link "archivedir")/%f" "%p"'
EOF

  )

  add_standby_server "async" "$new_node" "$pg_start_port"

  pg_start_port="$((pg_start_port + 1))"
  replication_tree["$fork_off"]="${replication_tree["$fork_off"]:-""} $new_node"
}


#: detach_node <node>
#:   Detach node.
#:
detach_node() {
  local node="$1"
  local children=(${replication_tree["$node"]:-})

  # At first, children must be removed.
  if [ ${#children[@]} -gt 0 ]; then
    log_error "$node has children, so remove them before detach $node"
    error "hint: remove ${children[@]}"
    exit 1
  fi

  local status=0
  stop_instance "$node" || status=$?
  if [ $status -ne 0 ]; then
    log_info "already stopped: $node"
  fi

  local key="" nd="" has_parent=1
  for key in ${!replication_tree[*]}; do
    for nd in ${replication_tree["$key"]}; do
      if [ "$nd" = "$node" ]; then
        has_parent=0
        break 2
      fi
    done
  done

  # If node is synchronous standby server, release it from sync mode.
  if [ $has_parent -eq 0 ]; then
    log_trace "==> edit $key.conf"
    (
      cd "$PGENV_CLUSTER_ROOT"
      local sync_standby_names="$(grep "synchronous_standby_names" "$key.conf" | \
                                   sed -e "s/synchronous_standby_names.*=.*'\(.*\)'/\1/")"
      local sync_array=( $(IFS=' ,' ; ar=(${sync_standby_names[@]:-}); echo "${ar[*]}") )

      sync_standby_names=()
      for n in ${sync_array[@]:-}; do
        if [ "$n" = "$node" ]; then
          continue
        fi
        sync_standby_names[${#sync_standby_names[@]}]="$n"
      done

      replace_string_in_file "del" "$key.conf" \
                             "synchronous_standby_names.*=.*" \
                             "synchronous_standby_names = '$(join_strings "," "${sync_standby_names[@]:-}")'"

      log_info "==> send sighup to instance '$key'"
      log_trace "pg_ctl reload -D $key"
      $(switch_context && pwd)/bin/pg_ctl reload -D "$key"
    )
  fi
}


#: Cluster operations


#: start_cluster
#:   Start all instances.
#:
start_cluster() {
  log_info "==> start cluster: $PGENV_CLUSTER_ROOT"
  start_instance "$primary_server"

  local instance=
  for instance in ${all_standby_servers[@]:-}; do
    start_instance "$instance"
  done
}


#: stop_cluster
#:   Stop all instances.
#:
stop_cluster() {
  log_info "==> stop cluster: $PGENV_CLUSTER_ROOT"
  stop_instance_safely "$primary_server"
}


#: show_cluster_status
#:   Show my cluster status.
#:
show_cluster_status() {
  local status=0
  local node=
  local instance_state=
  local indent=20

  (
    cd "$PGENV_CLUSTER_ROOT"
    println "[Cluster Servers]"
    println "# Primary server"
    printf "%-${indent}s" "$primary_server:$primary_port"
    eval "$(switch_context && pwd)/bin/pg_ctl" -D "$primary_server" status 2> /dev/null | head -1
    println ""

    println "# Synchronous standby servers"
    for ((i=0 ; i < ${#synchronous_standby_servers[@]}; i++)); do
      local standby_server="${synchronous_standby_servers[$i]}"
      local standby_port="${synchronous_standby_ports[$i]}"
      printf "%-${indent}s" "${synchronous_standby_servers[$i]}:${synchronous_standby_ports[$i]}"
      eval "$(switch_context && pwd)/bin/pg_ctl" -D "${synchronous_standby_servers[$i]}" status 2> /dev/null | head -1
    done
    println ""

    println "# Asynchronous standby servers"
    for ((i=0 ; i < ${#asynchronous_standby_servers[@]}; i++)); do
      local standby_server="${asynchronous_standby_servers[$i]}"
      local standby_port="${asynchronous_standby_ports[$i]}"
      printf "%-${indent}s" "${asynchronous_standby_servers[$i]}:${asynchronous_standby_ports[$i]}"
      eval "$(switch_context && pwd)/bin/pg_ctl" -D "${asynchronous_standby_servers[$i]}" status 2> /dev/null | head -1
    done
  )

  println

  println "[Replication Graph]"
  inspect_replication_tree &> /dev/null
  show_replication_tree

  println
}


#: Utils


#: split_instance_strings
#:   Split the specified strings with ':'
#:
#: ex:
#:   info=$(split_instance_strings "pgdata:9999")
#:
split_instance_strings() {
  (
    IFS=':'
    ar=($1)
    test -z "${ar[1]:-""}" && ar[1]=0
    printf "%s\n" "${ar[@]}"
  )
}


#: join_strings <separator> <string> [<string>..,]
#:   Join string.
#:
#:
join_strings() {
  local separator="$1"
  shift
  echo $(IFS="$separator" eval 'echo "$*"')
}


#: replace_string_in_file <mode> <file> <regex> <newstring>
#:   Delete text matches regex from the file and add newstring.
#:
#: ex:
#:   replace_string_in_file "postgresql.conf" "^port =" "port = 5433"
#:
replace_string_in_file() {
  local status=0
  local mode="$1"
  local org_file="$2"
  local source="$3"
  local newstring="$4"
  local tmpfile="$PGENV_TMPDIR"/"$(basename -- "$org_file").pgenvtmp"
  if [ "$mode" = "del" ]; then
    log_trace "$(self -vv): sed -e '/$source/d' $org_file"
    sed -e "/$source/d" "$org_file" > "$tmpfile" || status=$?
    echo "$newstring" >> "$tmpfile"
  else
    log_trace "$(self -vv): sed -e 's/$source/$newstring/g' $org_file"
    sed -e "s/$source/$newstring/g" "$org_file" > "$tmpfile" || status=$?
  fi

  if [ $status -ne 0 ]; then
    error "error: failed to write $tmpfile"
    abort "hint: $(dirname -- "$tmpfile") must be writable"
  fi

  log_trace "$(self): mv $tmpfile $org_file"
  mv "$tmpfile" "$org_file"
}
